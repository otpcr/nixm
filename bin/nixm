#!/usr/bin/env python3
# This file is placed in the Public Domain.
# pylint: disable=C,R,W0105,W0212,W0611,W0718


"program helpers"


import getpass
import inspect
import os
import pwd
import readline
import sys
import termios
import threading
import time
import _thread


sys.path.insert(0, os.getcwd())


from nixm.object  import Obj, parse
from nixm.persist import Workdir, modname, pidname, pidfile
from nixm.runtime import Errors, Reactor, later, launch


NAME = Reactor.__module__.split(".", maxsplit=2)[-2]
Workdir.wdr = os.path.expanduser(f"~/.{NAME}")


class Config(Obj):

    pass


class Commands:

    cmds = {}

    @staticmethod
    def add(func):
        Commands.cmds[func.__name__] = func

    @staticmethod
    def scan(mod):
        for key, cmdz in inspect.getmembers(mod, inspect.isfunction):
            if key.startswith("cb"):
                continue
            if 'event' in cmdz.__code__.co_varnames:
                Commands.add(cmdz)


def modloop(*pkgs):
    for pkg in pkgs:
        for modn in dir(pkg):
            if modn.startswith("__"):
                continue
            yield getattr(pkg, modn)


def scanner(*pkgs, init=False):
    result = []
    for mod in modloop(*pkgs):
        Commands.scan(mod)
        thr = None
        if init and "init" in dir(mod):
            thr = launch(mod.init, "init")
        result.append((mod, thr))
    return result


class Client(Reactor):

    def __init__(self):
        Reactor.__init__(self)
        self.register("command", command)

    def display(self, evt):
        for txt in evt.result:
            self.raw(txt)

    def raw(self, txt):
        raise NotImplementedError


class CLI(Client):

    def raw(self, txt):
        cprint(txt)


class Console(CLI):

    def callback(self, evt):
        CLI.callback(self, evt)
        evt.wait()

    def poll(self):
        evt = Event()
        evt.txt = input("> ")
        evt.type = "command"
        return evt


class Event:

    def __init__(self):
        self._ready  = threading.Event()
        self._thr    = None
        self.orig    = ""
        self.result  = []
        self.txt     = ""
        self.type    = "event"

    def __getattr__(self, key):
        return self.__dict__.get(key, "")

    def __str__(self):
        return str(self.__dict__)

    def ready(self):
        self._ready.set()

    def reply(self, txt):
        self.result.append(txt)

    def wait(self):
        self._ready.wait()
        if self._thr:
            self._thr.join()


def banner():
    tme = time.ctime(time.time()).replace("  ", " ")
    cprint(f"{NAME.upper()} since {tme}")
    

def command(bot, evt):
    if not evt.txt:
        evt.ready()
        return
    parse(evt, evt.txt)
    if "ident" in dir(bot):
        evt.orig = bot.ident
    funct = Commands.cmds.get(evt.cmd, None)
    if funct:
        try:
            funct(evt)
            bot.display(evt)
        except Exception as ex:
            later(ex)
    evt.ready()


def cprint(txt):
    print(txt)
    sys.stdout.flush()


def daemon(verbose=False):
    pid = os.fork()
    if pid != 0:
        os._exit(0)
    os.setsid()
    pid2 = os.fork()
    if pid2 != 0:
        os._exit(0)
    if not verbose:
        with open('/dev/null', 'r', encoding="utf-8") as sis:
            os.dup2(sis.fileno(), sys.stdin.fileno())
        with open('/dev/null', 'a+', encoding="utf-8") as sos:
            os.dup2(sos.fileno(), sys.stdout.fileno())
        with open('/dev/null', 'a+', encoding="utf-8") as ses:
            os.dup2(ses.fileno(), sys.stderr.fileno())
    os.umask(0)
    os.chdir("/")
    os.nice(10)


def errors():
    for err in Errors.errors:
        for line in err:
            cprint(line)


def forever():
    while True:
        try:
            time.sleep(1.0)
        except (KeyboardInterrupt, EOFError):
            _thread.interrupt_main()


def privileges():
    pwnam = pwd.getpwnam(getpass.getuser())
    os.setgid(pwnam.pw_gid)
    os.setuid(pwnam.pw_uid)
            

def wrap(func):
    old = None
    try:
        old = termios.tcgetattr(sys.stdin.fileno())
    except termios.error:
        pass
    try:
        func()
    except (KeyboardInterrupt, EOFError):
        cprint("")
    except Exception as ex:
        later(ex)
    finally:
        if old:
            termios.tcsetattr(sys.stdin.fileno(), termios.TCSADRAIN, old)



cfg = Config()


if os.path.exists("mods"):
    import mods.face as MODS
else:
    MODS = None


modpath = modname()


if os.path.exists(modpath):
    sys.path.insert(0, os.getcwd())
    import mods.face as MODULES
else:
    MODULES = None


def main():
    parse(cfg, " ".join(sys.argv[1:]))
    if "d" in cfg.opts:
        daemon("v" in cfg.opts)
        privileges()
        pidfile(pidname(NAME))
        scanner(MODS, MODULES, init=True)
        forever()
    elif "c" in cfg.opts:
        readline.redisplay()
        banner()
        for mod, thr in scanner(MODS, MODULES, init="i" in cfg.opts):
            if "v" in cfg.opts and "output" in dir(mod):
                mod.output = cprint
            if thr and "w" in cfg.opts:
                thr.join()
        csl = Console()
        csl.start()
        forever()
    else:
        csl = CLI()
        scanner(MODS, MODULES)
        evt = Event()
        evt.txt = cfg.txt
        evt.type = "command"
        command(csl, evt)
        evt.wait()


if __name__ == "__main__":
    wrap(main)
    errors()
