#!/usr/bin/env python3
# This file is placed in the Public Domain.
# pylint: disable=C,R,W0105,W0212,W0718


"tinder"


import inspect
import os
import shutil
import sys
import termios
import threading
import time
import _thread


sys.path.insert(0, os.getcwd())


from nixm.object  import Object, Obj, parse
from nixm.persist import Workdir, laps, modname, skel
from nixm.runtime import Errors, Reactor, later, launch


NAME = Reactor.__module__.split(".", maxsplit=2)[-2]
Workdir.wdr = os.path.expanduser(f"~/.{NAME}")

class Config(Obj):

    pass


cfg = Config()


class Client(Reactor):

    def __init__(self):
        Reactor.__init__(self)
        self.register("command", command)

    def display(self, evt):
        for txt in evt.result:
            self.raw(txt)

    def raw(self, txt):
        raise NotImplementedError


class Commands:

    cmds = {}

    @staticmethod
    def add(func):
        Commands.cmds[func.__name__] = func

    @staticmethod
    def scan(mod):
        for key, cmdz in inspect.getmembers(mod, inspect.isfunction):
            if key.startswith("cb"):
                continue
            if 'event' in cmdz.__code__.co_varnames:
                Commands.add(cmdz)


def command(bot, evt):
    parse(evt, evt.txt)
    if "ident" in dir(bot):
        evt.orig = bot.ident
    funct = Commands.cmds.get(evt.cmd, None)
    if funct:
        try:
            funct(evt)
            bot.display(evt)
        except Exception as ex:
            later(ex)
    evt.ready()


def scanner(*pkgs, init=False):
    result = []
    for mod in modloop(*pkgs):
        Commands.scan(mod)
        thr = None
        if init and "init" in dir(mod):
            thr = launch(mod.init, "init")
        result.append((mod, thr))
    return result


class Event:

    def __init__(self):
        self._ready  = threading.Event()
        self._thr    = None
        self.orig    = ""
        self.result  = []
        self.txt     = ""
        self.type    = "event"

    def __getattr__(self, key):
        return self.__dict__.get(key, "")

    def __str__(self):
        return str(self.__dict__)

    def ready(self):
        self._ready.set()

    def reply(self, txt):
        self.result.append(txt)

    def wait(self):
        self._ready.wait()
        if self._thr:
            self._thr.join()


"runtime"


if os.path.exists("mods"):
    import mods.face as MODS
    if "rss" in dir(MODS):
        MODS.rss.DEBUG = True
else:
    MODS = None


modpath = modname()


if os.path.exists(modpath):
    sys.path.insert(0, os.getcwd())
    import mods.face as MODULES
    if "rss" in dir(MODULES):
        MODULES.rss.DEBUG = True
else:
    MODULES = None


LAP = 1
NRS = 1
NRCOMMAND = 1
PERCALL   = 1
STARTTIME = time.time()


events = []
paylock = _thread.allocate_lock()


param = Object()
param.cmd = [""]
param.dpl = ["hnrss title,url"]
param.fnd = ["log", "todo", "rss", "config", "urls"]
param.imp = ["tests/feeds.opml"]
param.log = ["bla"]
param.mod = [""]
param.mre = [""]
param.nme = ["hnrss hackernews"]
param.pwd = ["bla mekker"]
param.rem = ["hnrss"]
param.res = [""]
param.rss = ["http://hnrss.org/newest", ""]
param.tdo = ["mekker", ""]
param.ver = [""]


class CLI(Client):

    def __init__(self):
        Client.__init__(self)
        self.register("event", command)

    def callback(self, evt):
        Client.callback(self, evt)
        if "w" in cfg.opts:
            evt.wait()

    def raw(self, txt):
        if "v" in cfg.opts:
            print(txt)


def banner():
    tme = time.ctime(time.time()).replace("  ", " ")
    print(f"{NAME.upper()} since {tme}")


def consume(evts):
    for evt in evts:
        evt.wait()


def errors():
    for erring in Errors.errors:
        for line in erring:
            print(line)


def modloop(*pkgs):
    for pkg in pkgs:
        for name in dir(pkg):
            if name.startswith("__"):
                continue
            yield getattr(pkg, name)


def payload(clt):
    nmr = 0
    for cmdd in sorted(Commands.cmds):
        for ex in getattr(param, cmdd, [""]):
            evt = Event()
            evt.txt = cmdd + " " + ex
            clt.put(evt)
            events.append(evt)
            nmr += 1
    return nmr


def wrap(function):
    old3 = None
    try:
        old3 = termios.tcgetattr(sys.stdin.fileno())
    except termios.error:
        pass
    try:
        function()
    except (KeyboardInterrupt, EOFError):
        pass
    except Exception as ex:
        later(ex)
    finally:
        if old3:
            termios.tcsetattr(sys.stdin.fileno(), termios.TCSADRAIN, old3)


def main():
    Workdir.wdr = ".test"
    parse(cfg, " ".join(sys.argv[1:]))
    scanner(MODS,MODULES)
    nrcommands = len(Commands.cmds) or 1
    if "v" in cfg.opts:
        banner()
    if "f" not in cfg.opts:
        if os.path.exists(Workdir.wdr):
            shutil.rmtree(Workdir.wdr)
    skel()
    clt = CLI()
    clt.start()
    nrs = cfg.index or 1
    thrs = []
    for _nr in range(nrs):
        thrs.append(launch(payload, "payload", clt))
    for thr in thrs:
        thr.join()
    consume(events)
    if "v" in cfg.opts:
        endtime = time.time()
        lap = laps(endtime-STARTTIME)
        percall = (endtime-STARTTIME)/(nrs*nrcommands)
        print(",".join(Commands.cmds))
        print(f"{lap} {nrs} {nrcommands} {percall}")
        if not Errors.errors:
            print("no errors")


if __name__ == "__main__":
    wrap(main)
    errors()
